"""
Migrate management command (modernized for argparse-style options).
"""

import sys

from django.core.management.base import BaseCommand
from django.conf import settings

from south import migration


class Command(BaseCommand):
    help = "Runs migrations for all apps."
    args = "[appname] [migrationname|zero] [--all] [--list] [--skip] [--merge] [--no-initial-data] [--fake] [--db-dry-run]"

    def add_arguments(self, parser):
        parser.add_argument('--all', action='store_true', dest='all_apps', default=False,
                            help='Run the specified migration for all apps.')
        parser.add_argument('--list', action='store_true', dest='list', default=False,
                            help='List migrations noting those that have been applied')
        parser.add_argument('--skip', action='store_true', dest='skip', default=False,
                            help='Will skip over out-of-order missing migrations')
        parser.add_argument('--merge', action='store_true', dest='merge', default=False,
                            help='Will run out-of-order missing migrations as they are - no rollbacks.')
        parser.add_argument('--no-initial-data', action='store_true', dest='no_initial_data', default=False,
                            help='Skips loading initial data if specified.')
        parser.add_argument('--fake', action='store_true', dest='fake', default=False,
                            help="Pretends to do the migrations, but doesn't actually execute them.")
        parser.add_argument('--db-dry-run', action='store_true', dest='db_dry_run', default=False,
                            help="Doesn't execute the SQL generated by the db methods, and doesn't store a record that the migration(s) occurred. Useful to test migrations before applying them.")

    def handle(self, app=None, target=None, skip=False, merge=False, backwards=False, fake=False, db_dry_run=False, list=False, **options):

        # Work out what the resolve mode is
        resolve_mode = merge and "merge" or (skip and "skip" or None)

        # NOTE: THIS IS DUPLICATED FROM django.core.management.commands.syncdb
        # This code imports any module named 'management' in INSTALLED_APPS.
        # The 'management' module is the preferred way of listening to post_syncdb
        # signals, and since we're sending those out with create_table migrations,
        # we need apps to behave correctly.
        for app_name in settings.INSTALLED_APPS:
            try:
                __import__(app_name + '.management', {}, {}, [''])
            except ImportError as exc:
                msg = exc.args[0] if exc.args else ''
                if not msg.startswith('No module named') or 'management' not in msg:
                    raise
        # END DJANGO DUPE CODE

        # if all_apps flag is set, shift app over to target
        if options.get('all_apps', False):
            target = app
            app = None

        # Migrate each app
        if app:
            apps = [migration.get_app(app.split(".")[-1])]
            if apps == [None]:
                self.stdout.write("The app '%s' does not appear to use migrations." % app)
                self.stdout.write("./manage.py migrate " + self.args)
                return
        else:
            apps = migration.get_migrated_apps()

        if list and apps:
            list_migrations(apps)

        if not list:
            tree = migration.dependency_tree()

            for app in apps:
                result = migration.migrate_app(
                    app,
                    tree,
                    resolve_mode = resolve_mode,
                    target_name = target,
                    fake = fake,
                    db_dry_run = db_dry_run,
                    verbosity = int(options.get('verbosity', 0)),
                    load_inital_data = not options.get('no_initial_data', False),
                    skip = skip,
                )
                if result is False:
                    return

def list_migrations(apps):
    from south.models import MigrationHistory
    apps = list(apps)
    names = [migration.get_app_name(app) for app in apps]
    applied_migrations = MigrationHistory.objects.filter(app_name__in=names)
    applied_migrations = ['%s.%s' % (mi.app_name,mi.migration) for mi in applied_migrations]
    # Print a blank line then each app's migrations
    sys.stdout.write("\n")
    for app in apps:
        sys.stdout.write(migration.get_app_name(app) + "\n")
        all_migrations = migration.get_migration_names(app)
        for migration_name in all_migrations:
            long_form = '%s.%s' % (migration.get_app_name(app),migration_name)
            if long_form in applied_migrations:
                sys.stdout.write(format_migration_list_item(migration_name) + "\n")
            else:
                sys.stdout.write(format_migration_list_item(migration_name, applied=False) + "\n")
        sys.stdout.write("\n")


def format_migration_list_item(name, applied=True):
    if applied:
        return '   * %s' % name
    return '     %s' % name
